Files compiled from: C:\Users\ossia\Documents\GitHub\AdvancedGameplay\Source\AdvancedGameplay\Spider
Included extensions: .cpp, .h
Search depth: 4
==================================================



=== FILE: ProceduralSpiderGaitComponent.cpp ===
#include "ProceduralSpiderGaitComponent.h"
#include "GameFramework/Actor.h"
#include "Engine/World.h"
#include "DrawDebugHelpers.h"
#include "GameFramework/Character.h"

UProceduralSpiderGaitComponent::UProceduralSpiderGaitComponent()
{
	PrimaryComponentTick.bCanEverTick = true;
}

void UProceduralSpiderGaitComponent::BeginPlay()
{
	Super::BeginPlay();
	InitializeDefaultsIfEmpty();
}

void UProceduralSpiderGaitComponent::InitializeDefaultsIfEmpty()
{
	if (Legs.Num() != 8)
	{
		Legs.Empty();
		Legs.SetNum(8);

		Legs[0].LegId = ESpiderLeg::L1; Legs[0].IKBoneName = TEXT("Leg1_IKtarsus_L"); Legs[0].EndBoneName = TEXT("Leg1_tarsus_L");
		Legs[1].LegId = ESpiderLeg::L2; Legs[1].IKBoneName = TEXT("Leg2_IKtarsus_L"); Legs[1].EndBoneName = TEXT("Leg2_tarsus_L");
		Legs[2].LegId = ESpiderLeg::L3; Legs[2].IKBoneName = TEXT("Leg3_IKtarsus_L"); Legs[2].EndBoneName = TEXT("Leg3_tarsus_L");
		Legs[3].LegId = ESpiderLeg::L4; Legs[3].IKBoneName = TEXT("Leg4_IKtarsus_L"); Legs[3].EndBoneName = TEXT("Leg4_tarsus_L");

		Legs[4].LegId = ESpiderLeg::R1; Legs[4].IKBoneName = TEXT("Leg1_IKtarsus_R"); Legs[4].EndBoneName = TEXT("Leg1_tarsus_R");
		Legs[5].LegId = ESpiderLeg::R2; Legs[5].IKBoneName = TEXT("Leg2_IKtarsus_R"); Legs[5].EndBoneName = TEXT("Leg2_tarsus_R");
		Legs[6].LegId = ESpiderLeg::R3; Legs[6].IKBoneName = TEXT("Leg3_IKtarsus_R"); Legs[6].EndBoneName = TEXT("Leg3_tarsus_R");
		Legs[7].LegId = ESpiderLeg::R4; Legs[7].IKBoneName = TEXT("Leg4_IKtarsus_R"); Legs[7].EndBoneName = TEXT("Leg4_tarsus_R");
	}

	AActor* Owner = GetOwner();
	ACharacter* Character = Cast<ACharacter>(Owner);
	USkeletalMeshComponent* Mesh = Character ? Character->GetMesh() : Owner->FindComponentByClass<USkeletalMeshComponent>();
	if (!Mesh) return;

	const FTransform OwnerWorld = Owner->GetActorTransform();

	for (FSpiderLegRuntime& Leg : Legs)
	{
		Leg.bInStance = true;
		Leg.bStepping = false;
		Leg.StepAlpha = 0.0f;

		// Foot position in the current (rest) pose
		const FVector FootWorld = Mesh->GetSocketLocation(Leg.EndBoneName);

		// Store rest position relative to the actor (component-like reference)
		Leg.RestOffset_Component = OwnerWorld.InverseTransformPosition(FootWorld);

		// Plant there (trace straight down from that foot)
		const FVector From = FootWorld + FVector(0, 0, TraceUp);

		FVector HitP, HitN;
		if (SampleGround(From, HitP, HitN))
		{
			Leg.PlantedWorld = HitP;
			Leg.IKTargetWorld = FTransform(Owner->GetActorRotation(), HitP);
		}
		else
		{
			Leg.PlantedWorld = FootWorld;
			Leg.IKTargetWorld = FTransform(Owner->GetActorRotation(), FootWorld);
		}
	}
}

void UProceduralSpiderGaitComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
{
	Super::TickComponent(DeltaTime, TickType, ThisTickFunction);

	UpdateCycle(DeltaTime);

	const float Cycle01 = FMath::Fmod(AccumTime / FMath::Max(0.001f, CycleSeconds), 1.0f);

	for (FSpiderLegRuntime& Leg : Legs)
	{
		UpdateLeg(Leg, DeltaTime, Cycle01);
	}
}

void UProceduralSpiderGaitComponent::UpdateCycle(float DeltaTime)
{
	AccumTime += DeltaTime;

	const float Cycle01 = FMath::Fmod(AccumTime / FMath::Max(0.001f, CycleSeconds), 1.0f);

	// Toggle swing group at half cycle boundaries
	const int32 Half = (Cycle01 < 0.5f) ? 0 : 1;
	if (Half != PrevHalf)
	{
		PrevHalf = Half;
		bGroupASwings = (Half == 0);
	}
}

bool UProceduralSpiderGaitComponent::IsLegInGroupA(ESpiderLeg LegId) const
{
	// Alternating tetrapod example group.
	// GroupA: L1 L3 R2 R4 (diagonal-ish pairing)
	return (LegId == ESpiderLeg::L1) || (LegId == ESpiderLeg::L3) || (LegId == ESpiderLeg::R2) || (LegId == ESpiderLeg::R4);
}

bool UProceduralSpiderGaitComponent::IsLegAllowedToSwing(const FSpiderLegRuntime& Leg, float Cycle01) const
{
	// Swing window within the current half-cycle.
	// Stance fraction = DutyFactor; swing fraction = 1-DutyFactor (duty > 0.6).	
	const float SwingFrac = FMath::Clamp(1.0f - DutyFactor, 0.05f, 0.45f);

	// In each half (0..0.5 or 0.5..1), allow swing near the beginning of that half.
	const float HalfStart = bGroupASwings ? 0.0f : 0.5f;
	const float Local = (Cycle01 - HalfStart) * 2.0f; // map to 0..1 inside half
	if (Local < 0.0f || Local > 1.0f) return false;

	const bool bInThisGroup = bGroupASwings ? IsLegInGroupA(Leg.LegId) : !IsLegInGroupA(Leg.LegId);

	return bInThisGroup && (Local <= SwingFrac);
}

bool UProceduralSpiderGaitComponent::SampleGround(const FVector& WorldFrom, FVector& OutHitPoint, FVector& OutHitNormal) const
{
	UWorld* World = GetWorld();
	if (!World) return false;

	const FVector Start = WorldFrom;
	const FVector End   = WorldFrom - FVector(0,0,TraceDown + TraceUp);

	FHitResult Hit;
	FCollisionQueryParams Params(SCENE_QUERY_STAT(SpiderFootTrace), false, GetOwner());

	const bool bHit = World->LineTraceSingleByChannel(Hit, Start, End, GroundTraceChannel, Params);
	if (!bHit) return false;

	OutHitPoint = Hit.ImpactPoint;
	OutHitNormal = Hit.ImpactNormal;
	return true;
}

FVector UProceduralSpiderGaitComponent::ComputeDesiredFootPoint(const FSpiderLegRuntime& Leg) const
{
	AActor* Owner = GetOwner();
	if (!Owner) return Leg.PlantedWorld;

	const FTransform OwnerWorld = Owner->GetActorTransform();

	// Start at rest footprint
	FVector Guess = OwnerWorld.TransformPosition(Leg.RestOffset_Component);

	// Add stride only if moving
	const FVector Velocity = Owner->GetVelocity();
	const float Speed2D = FVector(Velocity.X, Velocity.Y, 0.0f).Size();

	if (Speed2D > 2.0f)
	{
		const FVector Forward = Owner->GetActorForwardVector();
		Guess += Forward * StepReachForward;
	}

	FVector HitP, HitN;
	if (SampleGround(Guess + FVector(0, 0, TraceUp), HitP, HitN))
	{
		return HitP;
	}
	return Leg.PlantedWorld;
}

void UProceduralSpiderGaitComponent::BeginStep(FSpiderLegRuntime& Leg, const FVector& NewEndWorld)
{
	Leg.bStepping = true;
	Leg.bInStance = false;
	Leg.StepAlpha = 0.0f;
	Leg.StepStartWorld = Leg.PlantedWorld;
	Leg.StepEndWorld = NewEndWorld;
}

void UProceduralSpiderGaitComponent::TickStep(FSpiderLegRuntime& Leg, float DeltaTime, float SwingDuration)
{
	Leg.StepAlpha = FMath::Clamp(Leg.StepAlpha + (DeltaTime / FMath::Max(0.001f, SwingDuration)), 0.0f, 1.0f);

	// Arc lift
	const float A = Leg.StepAlpha;
	const FVector Flat = FMath::Lerp(Leg.StepStartWorld, Leg.StepEndWorld, A);
	const float Lift = FMath::Sin(A * PI) * StepHeight;
	const FVector Pos = Flat + FVector(0,0,Lift);

	Leg.IKTargetWorld = FTransform(GetOwner()->GetActorRotation(), Pos);

	if (Leg.StepAlpha >= 1.0f)
	{
		Leg.bStepping = false;
		Leg.bInStance = true;
		Leg.PlantedWorld = Leg.StepEndWorld;
		Leg.IKTargetWorld = FTransform(GetOwner()->GetActorRotation(), Leg.PlantedWorld);
	}
}

void UProceduralSpiderGaitComponent::UpdateLeg(FSpiderLegRuntime& Leg, float DeltaTime, float Cycle01)
{
	const float SwingDuration = CycleSeconds * FMath::Clamp(1.0f - DutyFactor, 0.05f, 0.45f);

	Leg.DesiredWorld = ComputeDesiredFootPoint(Leg);

	if (Leg.bStepping)
	{
		TickStep(Leg, DeltaTime, SwingDuration);
		return;
	}

	// stance: lock target to planted point
	Leg.IKTargetWorld = FTransform(GetOwner()->GetActorRotation(), Leg.PlantedWorld);
	
	DrawDebugSphere(GetWorld(), Leg.IKTargetWorld.GetLocation(), 6.0f, 10, FColor::Red, false, 0.0f);

	// if allowed to swing this tick, and foot needs repositioning => step
	if (IsLegAllowedToSwing(Leg, Cycle01))
	{
		const float Dist = FVector::Dist2D(Leg.PlantedWorld, Leg.DesiredWorld);
		if (Dist > StepTriggerDistance)
		{
			BeginStep(Leg, Leg.DesiredWorld);
		}
	}
}

bool UProceduralSpiderGaitComponent::GetIKTarget(ESpiderLeg Leg, FTransform& OutWorldTarget) const
{
	for (const FSpiderLegRuntime& L : Legs)
	{
		if (L.LegId == Leg)
		{
			OutWorldTarget = L.IKTargetWorld;
			return true;
		}
	}
	return false;
}

=== FILE: ProceduralSpiderGaitComponent.h ===
#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "SpiderGaitTypes.h"
#include "ProceduralSpiderGaitComponent.generated.h"

UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
class ADVANCEDGAMEPLAY_API UProceduralSpiderGaitComponent : public UActorComponent
{
	GENERATED_BODY()

public:
	UProceduralSpiderGaitComponent();

	virtual void BeginPlay() override;
	virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;

	// Read by AnimInstance
	UFUNCTION(BlueprintCallable, BlueprintPure)
	bool GetIKTarget(ESpiderLeg Leg, FTransform& OutWorldTarget) const;

public:
	// --- Gait tuning (based on paper ranges) ---
	// Duty factor > 0.6 means long stance time.
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Gait")
	float DutyFactor = 0.68f;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Gait")
	float CycleSeconds = 1.6f; // typical gait cycle ~1.55â€“1.77s in the referenced study

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Gait")
	float StepHeight = 6.0f;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Gait")
	float StepTriggerDistance = 10.0f;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Gait")
	float StepReachForward = 12.0f;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Gait")
	float TraceUp = 30.0f;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Gait")
	float TraceDown = 80.0f;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Gait")
	TEnumAsByte<ECollisionChannel> GroundTraceChannel = ECC_WorldStatic;

	// 8 legs
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Rig")
	TArray<FSpiderLegRuntime> Legs;

private:
	float AccumTime = 0.0f;
	
	int32 PrevHalf = -1;

	// group toggle each half-cycle
	bool bGroupASwings = true;

private:
	void InitializeDefaultsIfEmpty();
	void UpdateCycle(float DeltaTime);
	void UpdateLeg(FSpiderLegRuntime& Leg, float DeltaTime, float Cycle01);

	bool IsLegInGroupA(ESpiderLeg LegId) const;
	bool IsLegAllowedToSwing(const FSpiderLegRuntime& Leg, float Cycle01) const;

	bool SampleGround(const FVector& WorldFrom, FVector& OutHitPoint, FVector& OutHitNormal) const;
	FVector ComputeDesiredFootPoint(const FSpiderLegRuntime& Leg) const;

	void BeginStep(FSpiderLegRuntime& Leg, const FVector& NewEndWorld);
	void TickStep(FSpiderLegRuntime& Leg, float DeltaTime, float SwingDuration);
};

=== FILE: SpiderAnimInstance.cpp ===
#include "SpiderAnimInstance.h"
#include "ProceduralSpiderGaitComponent.h"
#include "GameFramework/Pawn.h"

void USpiderAnimInstance::NativeUpdateAnimation(float DeltaSeconds)
{
	APawn* Pawn = TryGetPawnOwner();
	if (!Pawn) return;

	SpiderGait = Pawn->FindComponentByClass<UProceduralSpiderGaitComponent>();
	if (!SpiderGait) return;

	IKTargets.SetNum(8);
	
	USkeletalMeshComponent* SkelComp = GetSkelMeshComponent();
	
	for (int i = 0; i < 8; ++i)
	{
		ESpiderLeg Leg = static_cast<ESpiderLeg>(i);
		FTransform Target;
		if (SpiderGait->GetIKTarget(Leg, Target))
		{
			if (SkelComp)
			{
				IKTargets[i] = Target.GetRelativeTransform(SkelComp->GetComponentTransform());
			}
		}
	}
}

bool USpiderAnimInstance::GetIKTarget(ESpiderLeg Leg, FTransform& OutWorldTarget) const
{
	const int32 Index = static_cast<int32>(Leg);
	if (!IKTargets.IsValidIndex(Index))
	{
		return false;
	}

	OutWorldTarget = IKTargets[Index];
	return true;
}


=== FILE: SpiderAnimInstance.h ===
#pragma once

#include "CoreMinimal.h"
#include "Animation/AnimInstance.h"
#include "SpiderGaitTypes.h"
#include "SpiderAnimInstance.generated.h"

class UProceduralSpiderGaitComponent;

UCLASS()
class ADVANCEDGAMEPLAY_API USpiderAnimInstance : public UAnimInstance
{
	GENERATED_BODY()

public:
	virtual void NativeUpdateAnimation(float DeltaSeconds) override;

	// Optional: expose a getter instead of a TMap for easier AnimGraph wiring later.
	UFUNCTION(BlueprintCallable, BlueprintPure)
	bool GetIKTarget(ESpiderLeg Leg, FTransform& OutWorldTarget) const;

protected:
	UPROPERTY(Transient, BlueprintReadOnly)
	TObjectPtr<UProceduralSpiderGaitComponent> SpiderGait;

	// A TMap is awkward to use in AnimGraph/Blueprint. Works in C++, but pain in BP.
	UPROPERTY(Transient, BlueprintReadOnly)
	TArray<FTransform> IKTargets; // size 8, index = (int)ESpiderLeg
};

=== FILE: SpiderCharacter.cpp ===
#include "SpiderCharacter.h"
#include "ProceduralSpiderGaitComponent.h"
#include "Components/CapsuleComponent.h"
#include "GameFramework/CharacterMovementComponent.h"

ASpiderCharacter::ASpiderCharacter()
{
	PrimaryActorTick.bCanEverTick = true;

	// Character defaults that usually help for creatures
	GetCharacterMovement()->bOrientRotationToMovement = true;
	GetCharacterMovement()->RotationRate = FRotator(0.0f, 540.0f, 0.0f);

	// You can tune these later
	GetCharacterMovement()->MaxWalkSpeed = 200.0f;
	GetCharacterMovement()->BrakingDecelerationWalking = 2048.0f;

	SpiderGait = CreateDefaultSubobject<UProceduralSpiderGaitComponent>(TEXT("ProceduralSpiderGait"));
}

void ASpiderCharacter::BeginPlay()
{
	Super::BeginPlay();
}

=== FILE: SpiderCharacter.h ===
#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Character.h"
#include "SpiderCharacter.generated.h"

class UProceduralSpiderGaitComponent;

UCLASS()
class ADVANCEDGAMEPLAY_API ASpiderCharacter : public ACharacter
{
	GENERATED_BODY()

public:
	ASpiderCharacter();

protected:
	virtual void BeginPlay() override;

public:
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category="Spider")
	TObjectPtr<UProceduralSpiderGaitComponent> SpiderGait;
};

=== FILE: SpiderGaitTypes.h ===
// SpiderGaitTypes.h
#pragma once

#include "CoreMinimal.h"
#include "SpiderGaitTypes.generated.h"

UENUM(BlueprintType)
enum class ESpiderLeg : uint8
{
	L1, L2, L3, L4,
	R1, R2, R3, R4
};

USTRUCT(BlueprintType)
struct FSpiderLegRuntime
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	ESpiderLeg LegId = ESpiderLeg::L1;

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	FName IKBoneName;          // e.g. Leg1_IKtarsus_L

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	FName EndBoneName;         // e.g. Leg1_tarsus_L

	UPROPERTY(BlueprintReadOnly)
	bool bInStance = true;

	UPROPERTY(BlueprintReadOnly)
	bool bStepping = false;

	UPROPERTY(BlueprintReadOnly)
	float PhaseOffset = 0.0f;  // per-leg offset within cycle

	UPROPERTY(BlueprintReadOnly)
	FVector PlantedWorld = FVector::ZeroVector;

	UPROPERTY(BlueprintReadOnly)
	FVector DesiredWorld = FVector::ZeroVector;

	UPROPERTY(BlueprintReadOnly)
	FTransform IKTargetWorld = FTransform::Identity;

	// Swing interpolation
	UPROPERTY(BlueprintReadOnly)
	float StepAlpha = 0.0f;

	UPROPERTY(BlueprintReadOnly)
	FVector StepStartWorld = FVector::ZeroVector;

	UPROPERTY(BlueprintReadOnly)
	FVector StepEndWorld = FVector::ZeroVector;
	
	UPROPERTY(BlueprintReadOnly)
	FVector RestOffset_Component = FVector::ZeroVector;
};